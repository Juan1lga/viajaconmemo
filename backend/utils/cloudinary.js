const cloudinary = require('cloudinary').v2; const streamifier = require('streamifier'); const configured = Boolean(process.env.CLOUDINARY_URL || (process.env.CLOUDINARY_CLOUD_NAME && process.env.CLOUDINARY_API_KEY && process.env.CLOUDINARY_API_SECRET)); if (!configured) { console.warn('Cloudinary no configurado. Las operaciones de subida y borrado de imágenes en Cloudinary estarán deshabilitadas.'); } else if (!process.env.CLOUDINARY_URL) { cloudinary.config({ cloud_name: process.env.CLOUDINARY_CLOUD_NAME, api_key: process.env.CLOUDINARY_API_KEY, api_secret: process.env.CLOUDINARY_API_SECRET, secure: true }); } const uploadBuffer = (buffer, folder) => { if (!configured) { return Promise.reject(new Error('Cloudinary no configurado')); } return new Promise((resolve, reject) => { const uploadStream = cloudinary.uploader.upload_stream({ folder: folder }, (error, result) => { if (error) { reject(error); } else { resolve(result); } }); streamifier.createReadStream(buffer).pipe(uploadStream); }); }; const getPublicIdFromUrl = (url) => { const regex = /v\d+\/(?:[^\/]+\/)*([^\.]+)/; const match = url.match(regex); return match ? match[1] : null; }; const deleteByUrl = async (url) => { if (!configured) { return; } const publicId = getPublicIdFromUrl(url); if (!publicId) { throw new Error('URL de Cloudinary inválida o no se pudo extraer el public_id'); } try { const result = await cloudinary.uploader.destroy(publicId); return result; } catch (error) { console.error('Error al borrar imagen de Cloudinary:', error); throw error; } }; const isCloudinaryUrl = (url) => { return url && url.includes('res.cloudinary.com'); }; module.exports = { configured, uploadBuffer, deleteByUrl, isCloudinaryUrl };